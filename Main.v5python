{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nLeftbottom = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nLefttop = Motor(Ports.PORT9, GearSetting.RATIO_18_1, True)\nLeftmiddle = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nRighttop = Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)\nRightmiddle = Motor(Ports.PORT15, GearSetting.RATIO_18_1, False)\nRightbottom = Motor(Ports.PORT16, GearSetting.RATIO_18_1, False)\nInertial1 = Inertial(Ports.PORT19)\ncontroller_1 = Controller(PRIMARY)\nlimitSwitch = Limit(brain.three_wire_port.a)\ncatapult = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nintake = Motor(Ports.PORT14, GearSetting.RATIO_18_1, False)\ngps = Gps(Ports.PORT8, 0.00, 0.00, MM, 180)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:\n#\tAuthor:\n#\tCreated:\n#\tConfiguration:\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nleftSide = MotorGroup(Leftbottom,Leftmiddle,Lefttop)\nrightSide = MotorGroup(Rightbottom,Rightmiddle,Righttop)\n\n\n# Define custom button class\ndef Stop_():\n    Leftbottom.set_stopping(BRAKE)\n    Rightbottom.set_stopping(BRAKE)\n    Righttop.set_stopping(BRAKE)\n    Rightmiddle.set_stopping(BRAKE)\n    Lefttop.set_stopping(BRAKE)\n    Leftmiddle.set_stopping(BRAKE)\n    Leftbottom.stop()\n    Rightbottom.stop()\n    Righttop.stop()\n    Lefttop.stop()\n    Leftmiddle.stop()\n    Rightmiddle.stop()\n\ndef Resetd():\n    Leftmiddle.set_position(0,DEGREES)\n    Leftbottom.set_position(0,DEGREES)\n    Rightbottom.set_position(0,DEGREES)\n    Righttop.set_position(0,DEGREES)\n    Lefttop.set_position(0,DEGREES)\n    Rightmiddle.set_position(0,DEGREES)\ndef Stop():\n    Leftmiddle.set_stopping(COAST)\n    Rightmiddle.set_stopping(COAST)\n    Leftbottom.set_stopping(COAST)\n    Rightbottom.set_stopping(COAST)\n    Righttop.set_stopping(COAST)\n    Lefttop.set_stopping(COAST)\n    Leftbottom.stop()\n    Rightbottom.stop()\n    Righttop.stop()\n    Lefttop.stop()\n    Leftmiddle.stop()\n    Rightmiddle.stop()\n\ndef turnControlLoop(angle_degrees):\n    # Constants for PID control\n    KP = 0.5\n    KI = 0.05\n    KD = 0.1\n\n    # Variables for PID control\n    last_error = 0\n    total_error = 0\n\n    # Calculate target angle\n    \n    target_angle = Inertial1.heading(DEGREES) + angle_degrees\n\n    # Normalize target angle to -180 to 180 degrees\n    if target_angle > 180:\n        target_angle -= 360\n    elif target_angle < -180:\n        target_angle += 360\n\n    # Loop until robot reaches target angle\n    while abs(Inertial1.heading(DEGREES) - target_angle) > 1:\n\n        # Calculate error\n        error = target_angle - Inertial1.heading(DEGREES)\n\n        # Calculate derivative of error\n        error_derivative = error - last_error\n\n        # Calculate integral of error\n        total_error += error\n\n        # Calculate motor power using PID control\n        motor_power = KP * error + KI * total_error + KD * error_derivative\n\n        # Set motor power\n        leftSide.spin(FORWARD)\n        rightSide.spin(REVERSE)\n        rightSide.set_velocity(motor_power,PERCENT)\n        leftSide.set_velocity(motor_power,PERCENT)\n        \n        # Store last error\n        last_error = error\n\n        # Wait for a short period of time\n        wait(.05,SECONDS)\n\n    # Stop motors when loop is finished\n    leftSide.stop()\n    rightSide.stop()\n\n    return\ndef driveControlLoop(distance_inches): \n\n    # Constants for PID control\n    KP = 0.43\n    KI = 0.05\n    KD = .00043\n\n    # Variables for PID control\n    last_error = 0\n    total_error = 0\n\n    # Calculate target position\n    target_position = distance_inches / (4 * math.pi) * 360\n\n    # Loop until robot reaches target position\n    while abs(leftSide.position(DEGREES) + rightSide.position(DEGREES)) / 2 < target_position:\n\n        # Calculate error\n        error_left = target_position - leftSide.position(DEGREES)\n        error_right = target_position - rightSide.position(DEGREES)\n\n        # Calculate derivative of error\n        error_derivative_left = error_left - last_error\n        error_derivative_right = error_right - last_error\n\n        # Calculate integral of error\n        total_error += error_left\n\n        # Calculate motor power using PID control\n        motor_power_left = KP * error_left + KI * total_error + KD * error_derivative_left\n        motor_power_right = KP * error_right + KI * total_error + KD * error_derivative_right\n\n        # Set motor power\n        leftSide.spin(FORWARD)\n        rightSide.spin(FORWARD)\n        rightSide.set_velocity(motor_power_left,PERCENT)\n        leftSide.set_velocity(motor_power_right,PERCENT)\n\n        # Store last error\n        last_error = error_left\n\n        # Wait for a short period of time\n        wait(.05,SECONDS)\n\n    # Stop motors when loop is finished\n    rightSide.stop()\n    leftSide.stop()\n\n    return \ndef odometry():\n    # Constants for odometry\n    WHEEL_RADIUS = 2.75  # inches\n    TICKS_PER_REV = 360 #DONT CHANGE THIS, this should be a constant\n    WHEELBASE_WIDTH = 5.25  # inches\n\n    # Variables for odometry\n    x = 0  # inches\n    y = 0  # inches\n    theta = 0  # radians\n\n    # Loop to continuously update position\n    while True:\n\n        # Get encoder values\n        left_ticks = Leftmiddle.position(DEGREES)\n        right_ticks = Rightmiddle.position(DEGREES)\n\n        # Calculate distance traveled by each wheel\n        left_distance = (left_ticks / TICKS_PER_REV) * (2 * math.pi * WHEEL_RADIUS)\n        right_distance = (right_ticks / TICKS_PER_REV) * (2 * math.pi * WHEEL_RADIUS)\n\n        # Calculate change in heading (in radians)\n        delta_theta = (right_distance - left_distance) / WHEELBASE_WIDTH\n\n        # Calculate average distance traveled\n        avg_distance = (left_distance + right_distance) / 2\n\n        # Update x, y, and theta values\n        x += avg_distance * math.cos(theta + (delta_theta / 2))\n        y += avg_distance * math.sin(theta + (delta_theta / 2))\n        theta += delta_theta\n\n        # Wait for a short period of time\n        wait(.05,SECONDS)\n\n    return (x, y)\n#this code might work\ndef gpsGoTo(xcord,ycord):\n    b = xcord - gps.x_position(MM)\n    c = ycord - gps.y_position(MM)\n    if b == 0 and c == 0:\n        pass\n    else:\n        a = math.sqrt(b**2 + c**2)\n        angle = math.asin((math.sin(90 / 180 * math.pi) * b) / a) / math.pi * 180\n        if c < 0:\n            angle = 180 - 180\n        IRightbottom(angle,.3)\n        IFWD(a,80,angle)\n    pass\npass\n    \ndef inertial():\n    (Inertial1.rotation(DEGREES))\n\ndef IFWD(d,s,h):\n\n    Resetd()\n\n    while ((Lefttop.position(DEGREES) + Righttop.position(DEGREES)) / 2) < d:\n        Rightmiddle.spin(FORWARD)\n        Leftbottom.spin(FORWARD)\n        Lefttop.spin(FORWARD)\n        Rightbottom.spin(FORWARD)\n        Righttop.spin(FORWARD)\n        Leftmiddle.spin(FORWARD)\n\n        pwr = abs(h - Inertial1.rotation(DEGREES)) * 2\n        if pwr > 100:\n            pwr = 100\n\n        if Inertial1.rotation(DEGREES)>(.5+h):\n            Leftbottom.set_velocity(s,PERCENT)\n            Lefttop.set_velocity(s,PERCENT)\n            Rightbottom.set_velocity(s+pwr,PERCENT)\n            Righttop.set_velocity(s+pwr,PERCENT)\n            Rightmiddle.set_velocity(s+pwr,PERCENT)\n            Leftmiddle.set_velocity(s,PERCENT)\n        elif Inertial1.rotation(DEGREES)<(h-.5):\n            Leftbottom.set_velocity(s+pwr,PERCENT)\n            Lefttop.set_velocity(s+pwr,PERCENT)\n            Rightbottom.set_velocity(s,PERCENT)\n            Righttop.set_velocity(s,PERCENT)\n            Leftmiddle.set_velocity(s+pwr,PERCENT)\n            Rightmiddle.set_velocity(s,PERCENT)\n        else:\n            Leftmiddle.set_velocity(s,PERCENT)\n            Leftbottom.set_velocity(s,PERCENT)\n            Lefttop.set_velocity(s,PERCENT)\n            Rightbottom.set_velocity(s,PERCENT)\n            Righttop.set_velocity(s,PERCENT)\n            Rightmiddle.set_velocity(s,PERCENT)\n    Stop()\n\ndef IREV(d,s,h):\n\n    Resetd()\n\n    while ((Lefttop.position(DEGREES) + Righttop.position(DEGREES)) / 2) > -d:\n\n        Leftbottom.spin(FORWARD)\n        Lefttop.spin(FORWARD)\n        Rightbottom.spin(FORWARD)\n        Righttop.spin(FORWARD)\n        Rightmiddle.spin(FORWARD)\n        Leftmiddle.spin(FORWARD)\n        pwr = abs(h -Inertial1.rotation(DEGREES)) * 2\n        if pwr > 100:\n            pwr = 100\n\n        if Inertial1.rotation(DEGREES)>(.5+h):\n            Leftmiddle.set_velocity(-s-pwr,PERCENT)\n            Leftbottom.set_velocity(-s-pwr,PERCENT)\n            Lefttop.set_velocity(-s-pwr,PERCENT)\n            Rightmiddle.set_velocity(-s,PERCENT)\n            Rightbottom.set_velocity(-s,PERCENT)\n            Righttop.set_velocity(-s,PERCENT)\n\n        elif Inertial1.rotation(DEGREES)<(h-.5):\n            Leftbottom.set_velocity(-s,PERCENT)\n            Lefttop.set_velocity(-s,PERCENT)\n            Leftmiddle.set_velocity(-s,PERCENT)\n            Rightmiddle.set_velocity(-s-pwr,PERCENT)\n            Rightbottom.set_velocity(-s-pwr,PERCENT)\n            Righttop.set_velocity(-s-pwr,PERCENT)\n\n        else:\n            Leftbottom.set_velocity(-s,PERCENT)\n            Lefttop.set_velocity(-s,PERCENT)\n            Rightbottom.set_velocity(-s,PERCENT)\n            Righttop.set_velocity(-s,PERCENT)\n            Rightmiddle.set_velocity(-s,PERCENT)\n            Leftmiddle.set_velocity(-s,PERCENT)\n    Stop_()\n\ndef IRightbottom(h,s):\n\n    Resetd()\n\n    while Inertial1.rotation(DEGREES)<h-.5:\n\n        pwr = (abs(h - Inertial1.rotation(DEGREES)) * s) + 5\n        if pwr > 40:\n            pwr = 40\n        Leftmiddle.set_velocity(pwr,PERCENT)\n        Leftbottom.set_velocity(pwr,PERCENT)\n        Lefttop.set_velocity(pwr,PERCENT)\n        Rightmiddle.set_velocity(-pwr,PERCENT)\n        Rightbottom.set_velocity(-pwr,PERCENT)\n        Righttop.set_velocity(-pwr,PERCENT)\n        Leftbottom.spin(FORWARD)\n        Lefttop.spin(FORWARD)\n        Rightbottom.spin(FORWARD)\n        Righttop.spin(FORWARD)\n        Rightmiddle.spin(FORWARD)\n        Leftmiddle.spin(FORWARD)\n\n    Stop()\n    wait(.05,SECONDS)\n\n    while Inertial1.rotation(DEGREES)>h+.5:\n\n        pwr = (abs(h - Inertial1.rotation(DEGREES)) * s) + 5\n        if pwr > 40:\n            pwr = 40\n        Leftmiddle.set_velocity(-pwr,PERCENT)\n        Leftbottom.set_velocity(-pwr,PERCENT)\n        Lefttop.set_velocity(-pwr,PERCENT)\n        Rightbottom.set_velocity(pwr,PERCENT)\n        Rightmiddle.set_velocity(pwr,PERCENT)\n        Righttop.set_velocity(pwr,PERCENT)\n        Leftbottom.spin(FORWARD)\n        Leftmiddle.spin(FORWARD)\n        Lefttop.spin(FORWARD)\n        Rightbottom.spin(FORWARD)\n        Righttop.spin(FORWARD)\n        Rightmiddle.spin(FORWARD)\n\n    Stop()\n\ndef ILeftbottom(h,s):\n\n    Resetd()\n\n    while Inertial1.rotation(DEGREES)>h+.5:\n\n        pwr = (abs(h - Inertial1.rotation(DEGREES)) * s) + 5\n        if pwr > 40:\n            pwr = 40\n        Leftmiddle.set_velocity(-pwr,PERCENT)\n        Leftbottom.set_velocity(-pwr,PERCENT)\n        Lefttop.set_velocity(-pwr,PERCENT)\n        Rightbottom.set_velocity(pwr,PERCENT)\n        Righttop.set_velocity(pwr,PERCENT)\n        Rightmiddle.set_velocity(pwr,PERCENT)\n        Leftbottom.spin(FORWARD)\n        Lefttop.spin(FORWARD)\n        Leftmiddle.spin(FORWARD)\n        Rightmiddle.spin(FORWARD)\n        Rightbottom.spin(FORWARD)\n        Righttop.spin(FORWARD)\n\n    Stop_()\n    wait(.05,SECONDS)\n\n    while Inertial1.rotation(DEGREES)<h-.5:\n\n        pwr = (abs(h - Inertial1.rotation(DEGREES)) * s) + 5\n        if pwr > 40:\n            pwr = 40\n\n        Leftmiddle.set_velocity(pwr,PERCENT)\n        Leftbottom.set_velocity(pwr,PERCENT)\n        Lefttop.set_velocity(pwr,PERCENT)\n        Rightbottom.set_velocity(-pwr,PERCENT)\n        Righttop.set_velocity(-pwr,PERCENT)\n        Rightmiddle.set_velocity(-pwr,PERCENT)\n        Leftmiddle.spin(FORWARD)\n        Rightmiddle.spin(FORWARD)\n        Leftbottom.spin(FORWARD)\n        Lefttop.spin(FORWARD)\n        Rightbottom.spin(FORWARD)\n        Righttop.spin(FORWARD)\n        \n    Stop_()\ndef turnleft(a,v):\n    Leftbottom.set_velocity(v,PERCENT)\n    Leftmiddle.set_velocity(v,PERCENT)\n    Lefttop.set_velocity(v,PERCENT)\n    Righttop.set_velocity(v,PERCENT)\n    Rightmiddle.set_velocity(v,PERCENT)\n    Rightbottom.set_velocity(v,PERCENT)\n    Leftmiddle.spin_for(REVERSE,a,DEGREES,wait=False)\n    Leftmiddle.spin_for(REVERSE,a,DEGREES,wait=False)\n    Rightmiddle.spin_for(FORWARD,a,DEGREES,wait=False)\n    Leftbottom.spin_for(FORWARD,a,DEGREES,wait=False)\n    Lefttop.spin_for(REVERSE,a,DEGREES,wait=False)\n    Rightbottom.spin_for(FORWARD,a,DEGREES,wait=False)\n    Righttop.spin_for(FORWARD,a,DEGREES,wait=False)\n\n#baba boy\ndef turnright(d,s):\n    Righttop.set_velocity(s,PERCENT)\n    Rightmiddle.set_velocity(s,PERCENT)\n    Rightbottom.set_velocity(s,PERCENT)\n    Lefttop.set_velocity(s,PERCENT)\n    Leftmiddle.set_velocity(s,PERCENT)\n    Leftbottom.set_velocity(s,PERCENT)\n    Righttop.spin_for(REVERSE,d,DEGREES,wait=False)\n    Rightmiddle.spin_for(REVERSE,d,DEGREES,wait=False)\n    Rightbottom.spin_for(REVERSE,d,DEGREES,wait=False)\n    Lefttop.spin_for(FORWARD,d,DEGREES,wait=False)\n    Leftmiddle.spin_for(FORWARD,d,DEGREES,wait=False)\n    Leftbottom.spin_for(FORWARD,d,DEGREES,wait=False)\n\ndef drive(a,v,direction):\n    if direction == 'f':\n        print(\"f\")\n        direction = FORWARD\n    elif direction == 'r':\n        direction = REVERSE\n    pass\n    Leftbottom.set_velocity(v,PERCENT)\n    Leftmiddle.set_velocity(v,PERCENT)\n    Lefttop.set_velocity(v,PERCENT)\n    Righttop.set_velocity(v,PERCENT)\n    Rightmiddle.set_velocity(v,PERCENT)\n    Rightbottom.set_velocity(v,PERCENT)\n    Leftmiddle.spin_for(direction,a,DEGREES,wait=False)\n    Leftmiddle.spin_for(direction,a,DEGREES,wait=False)\n    Rightmiddle.spin_for(direction,a,DEGREES,wait=False)\n    Leftbottom.spin_for(direction,a,DEGREES,wait=False)\n    Lefttop.spin_for(direction,a,DEGREES,wait=False)\n    Rightbottom.spin_for(direction,a,DEGREES,wait=False)\n    Righttop.spin_for(direction,a,DEGREES,wait=False)\ndef drivefint(d,s,ind,ins):\n    Leftbottom.set_velocity(s,PERCENT)\n    Leftmiddle.set_velocity(s,PERCENT)\n    Lefttop.set_velocity(s,PERCENT)\n    Righttop.set_velocity(s,PERCENT)\n    Rightmiddle.set_velocity(s,PERCENT)\n    Rightbottom.set_velocity(s,PERCENT)\n    Leftmiddle.spin_for(FORWARD,d,DEGREES,wait=False)\n    Leftmiddle.spin_for(FORWARD,d,DEGREES,wait=False)\n    Rightmiddle.spin_for(FORWARD,d,DEGREES,wait=False)\n    Leftbottom.spin_for(FORWARD,d,DEGREES,wait=False)\n    Lefttop.spin_for(FORWARD,d,DEGREES,wait=False)\n    Rightbottom.spin_for(FORWARD,d,DEGREES,wait=False)\n    Righttop.spin_for(FORWARD,d,DEGREES,wait=False)\n    intake.spin_for(FORWARD,ind,DEGREES,wait=False)\n    intake.set_velocity(ins,PERCENT)\n\npass\n\npass\ndef drivef(a,v):\n    Leftbottom.set_velocity(v,PERCENT)\n    Leftmiddle.set_velocity(v,PERCENT)\n    Lefttop.set_velocity(v,PERCENT)\n    Righttop.set_velocity(v,PERCENT)\n    Rightmiddle.set_velocity(v,PERCENT)\n    Rightbottom.set_velocity(v,PERCENT)\n    Leftmiddle.spin_for(FORWARD,a,DEGREES,wait=False)\n    Leftmiddle.spin_for(FORWARD,a,DEGREES,wait=False)\n    Rightmiddle.spin_for(FORWARD,a,DEGREES,wait=False)\n    Leftbottom.spin_for(FORWARD,a,DEGREES,wait=False)\n    Lefttop.spin_for(FORWARD,a,DEGREES,wait=False)\n    Rightbottom.spin_for(FORWARD,a,DEGREES,wait=False)\n    Righttop.spin_for(FORWARD,a,DEGREES,wait=False)\ndef driveR(a,v):\n    Leftbottom.set_velocity(v,PERCENT)\n    Leftmiddle.set_velocity(v,PERCENT)\n    Lefttop.set_velocity(v,PERCENT)\n    Righttop.set_velocity(v,PERCENT)\n    Rightmiddle.set_velocity(v,PERCENT)\n    Rightbottom.set_velocity(v,PERCENT)\n    Leftmiddle.spin_for(REVERSE,a,DEGREES,wait=False)\n    Leftmiddle.spin_for(REVERSE,a,DEGREES,wait=False)\n    Rightmiddle.spin_for(REVERSE,a,DEGREES,wait=False)\n    Leftbottom.spin_for(REVERSE,a,DEGREES,wait=False)\n    Lefttop.spin_for(REVERSE,a,DEGREES,wait=False)\n    Rightbottom.spin_for(REVERSE,a,DEGREES,wait=False)\n    Righttop.spin_for(REVERSE,a,DEGREES,wait=False)\ndef cataDown():\n    while True:\n        if limitSwitch.pressing():\n            catapult.stop(HOLD)\n            break\n        else: \n            catapult.spin(REVERSE)\ndef powerShot():\n    leftSide.set_velocity(100,PERCENT)\n    rightSide.set_velocity(100,PERCENT)\n    leftSide.spin_for(FORWARD,100,DEGREES,wait=False)\n    rightSide.spin_for(FORWARD,100,DEGREES,wait=False)\ndef weakShot():\n    leftSide.set_velocity(100,PERCENT)\n    rightSide.set_velocity(100,PERCENT)\n    leftSide.spin_for(REVERSE,100,DEGREES,wait=False)\n    rightSide.spin_for(REVERSE,100,DEGREES,wait=False)\ndef resetCalibration():\n    rightSide.set_position(0,DEGREES)\n    leftSide.set_position(0,DEGREES)\n    Inertial1.set_heading(0,DEGREES)\n\ndef pre_autonomous():\n    # actions to do when the program starts\n    brain.screen.clear_screen()\n    brain.screen.print(\"pre auton code\")\n    #calibrate sensors here\n    resetCalibration()\n    \ndef autonomous():\n    brain.screen.clear_screen()\n    brain.screen.print(\"autonomous code\")\n    # place automonous code here\n    \ndef user_control():\n    brain.screen.clear_screen()\n    # place driver control in this while loop\n    while True:\n        #Tank Drive\n        # leftSide.set_velocity(controller_1.axis3.position(),PERCENT)\n        # rightSide.set_velocity(controller_1.axis2.position(),PERCENT)\n        # leftSide.spin(FORWARD)\n        # rightSide.spin(FORWARD)\n\n        #Aracde Drive\n        # leftSide.set_velocity(controller_1.axis3.position() + controller_1.axis4.position(),PERCENT)\n        # rightSide.set_velocity(controller_1.axis3.position() - controller_1.axis4.position(),PERCENT)\n        # leftSide.spin(FORWARD)\n        # rightSide.spin(FORWARD)\n        #this template is for catapult, change to fit your shooting design\n        if limitSwitch.pressing():\n            catapult.stop(HOLD)\n        if controller_1.buttonR1.pressing() and limitSwitch.pressing():\n            catapult.spin_for(REVERSE,300,DEGREES,wait=True)\n        else:\n            catapult.spin(REVERSE)\n        #Intake code\n        if limitSwitch.pressing() and controller_1.buttonL1.pressing(): #if catapult is down and the intake button is being pressed, intake\n            intake.spin(FORWARD)\n        elif controller_1.buttonL2.pressing():\n            intake.spin(REVERSE)\n        else:\n            intake.stop()\n            \n# create competition instance\ncomp = Competition(user_control, autonomous)\npre_autonomous()\n","textLanguage":"python","rconfig":[{"port":[12],"name":"Leftbottom","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"Lefttop","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[11],"name":"Leftmiddle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[13],"name":"Righttop","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[15],"name":"Rightmiddle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[16],"name":"Rightbottom","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[19],"name":"Inertial1","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"limitSwitch","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":22},{"port":[10],"name":"catapult","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[14],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[8],"name":"gps","customName":true,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180","id":"partner"}}],"slot":7,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.1","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}